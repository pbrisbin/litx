{-# LANGUAGE DerivingVia #-}

module LitX.Execute
    ( ExecuteOptions
    , defaultExecuteOptions

    -- Prefer lens access because of the 'Endo'-based Options parsing
    , shebangL
    , bannerL
    , preambleL
    , commentCharL
    , languageL
    , executeModeL
    , executeArgsL
    , inheritEnvL
    , outputL
    , ExecuteMode(..)
    , InheritEnv(..)
    , Output(..)
    , executeMarkdown
    , setLanguageExecuteOptions
    ) where

import LitX.Prelude

import Data.Aeson
import qualified Data.ByteString.Lazy as BSL
import qualified Data.Text as T
import Data.Version
import LitX.CodeBlock
import LitX.Language
import LitX.Parse (Markdown, markdownCodeBlocks)
import qualified Paths_litx as Pkg
import System.Process.Typed

data ExecuteOptions = ExecuteOptions
    { eoLanguage :: Language
    , eoShebang :: Text
    , eoBanner :: Maybe Text
    , eoPreamble :: Maybe Text
    , eoCommentChar :: Text
    , eoExecuteMode :: ExecuteMode
    , eoExecuteArgs :: [String]
    , eoInheritEnv :: InheritEnv
    , eoOutput :: Output
    }
    deriving stock Generic
    deriving anyclass ToJSON

defaultExecuteOptions :: Language -> ExecuteOptions
defaultExecuteOptions language =
    setLanguageExecuteOptions language $ ExecuteOptions
        { eoLanguage = error "Programmer error: Language unset"
        , eoShebang = "/usr/bin/env cat"
        , eoBanner = Just $ T.intercalate
            "\n"
            [ defaultCommentChar
            , defaultCommentChar <> " " <> generatedBy
            , defaultCommentChar
            ]
        , eoPreamble = Nothing
        , eoCommentChar = defaultCommentChar
        , eoExecuteMode = Execute "cat"
        , eoExecuteArgs = []
        , eoInheritEnv = InheritEnv
        , eoOutput = OutputFile "/dev/null"
        }

defaultCommentChar :: Text
defaultCommentChar = "#"

generatedBy :: Text
generatedBy = "Generated by litx-v" <> pack (showVersion Pkg.version) <> "."

languageL :: Lens' ExecuteOptions Language
languageL = lens eoLanguage $ \x y -> x { eoLanguage = y }

shebangL :: Lens' ExecuteOptions Text
shebangL = lens eoShebang $ \x y -> x { eoShebang = y }

bannerL :: Lens' ExecuteOptions (Maybe Text)
bannerL = lens eoBanner $ \x y -> x { eoBanner = y }

preambleL :: Lens' ExecuteOptions (Maybe Text)
preambleL = lens eoPreamble $ \x y -> x { eoPreamble = y }

commentCharL :: Lens' ExecuteOptions Text
commentCharL = lens eoCommentChar $ \x y -> x { eoCommentChar = y }

executeModeL :: Lens' ExecuteOptions ExecuteMode
executeModeL = lens eoExecuteMode $ \x y -> x { eoExecuteMode = y }

executeArgsL :: Lens' ExecuteOptions [String]
executeArgsL = lens eoExecuteArgs $ \x y -> x { eoExecuteArgs = y }

inheritEnvL :: Lens' ExecuteOptions InheritEnv
inheritEnvL = lens eoInheritEnv $ \x y -> x { eoInheritEnv = y }

outputL :: Lens' ExecuteOptions Output
outputL = lens eoOutput $ \x y -> x { eoOutput = y }

data ExecuteMode
    = Execute String
    | NoExecute
    deriving stock Generic
    deriving anyclass ToJSON

data InheritEnv
    = InheritEnv
    | Don'tInheritEnv
    deriving stock Generic
    deriving anyclass ToJSON

data Output
    = OutputStdout
    | OutputFile FilePath

instance ToJSON Output where
    toJSON = toJSON . showOutput
    toEncoding = toEncoding . showOutput

instance IsString Output where
    fromString = \case
        "-" -> OutputStdout
        path -> OutputFile path

showOutput :: Output -> String
showOutput = \case
    OutputStdout -> "-"
    OutputFile path -> path

executeMarkdown :: MonadUnliftIO m => ExecuteOptions -> Markdown -> m ()
executeMarkdown ExecuteOptions {..} markdown = do
    case eoOutput of
        OutputStdout -> putStr script
        OutputFile path -> writeFile path script

    case eoExecuteMode of
        Execute cmd -> do
            let input = byteStringInput $ BSL.fromStrict $! encodeUtf8 script
            runProcess_ $ clearEnv $ setStdin input $ proc cmd eoExecuteArgs
        NoExecute -> pure ()
  where
    script = mconcat
        [ "#!" <> eoShebang <> "\n"
        , maybe "" (<> "\n") eoBanner
        , maybe "" (<> "\n\n") eoPreamble
        , renderCodeBlocks
        ]

    clearEnv = case eoInheritEnv of
        InheritEnv -> id
        Don'tInheritEnv -> setEnv []

    renderCodeBlocks :: Text
    renderCodeBlocks =
        T.intercalate "\n"
            $ map renderCodeBlock
            $ filter ((== eoLanguage) . codeBlockLanguage)
            $ markdownCodeBlocks markdown

    renderCodeBlock :: CodeBlock -> Text
    renderCodeBlock block =
        eoCommentChar <> " " <> sourceAnnotation block <> codeBlockContent block

    sourceAnnotation :: CodeBlock -> Text
    sourceAnnotation block =
        "source="
            <> pack (codeBlockPath block)
            <> maybe "" ((":" <>) . pack . show) (codeBlockLine block)
            <> "\n"

setLanguageExecuteOptions :: Language -> ExecuteOptions -> ExecuteOptions
setLanguageExecuteOptions = \case
    Bash ->
        (languageL .~ Bash)
            . (shebangL .~ "/usr/bin/env bash")
            . (bannerL ?~ ("#\n# " <> generatedBy <> "\n#\n###"))
            . (preambleL ?~ "set -euo pipefail")
            . (commentCharL .~ defaultCommentChar)
            . (executeModeL .~ Execute "bash")
            . (executeArgsL .~ ["-s", "-"])
