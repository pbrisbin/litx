module LitX.Options
    ( Options
    , optionsInput
    , optionsExecuteOptions
    , parseOptions
    , parseExecuteOptions
    , getExecuteOptions
    ) where

import LitX.Prelude

import Data.Semigroup (Dual(..), Endo(..))
import LitX.Execute
import LitX.Language
import LitX.Parse
import Options.Applicative

data Options = Options
    { oInput :: Input
    , oExecuteOptions :: Dual (Endo ExecuteOptions)
    }

optionsInput :: Options -> Input
optionsInput = oInput

optionsExecuteOptions :: Options -> Dual (Endo ExecuteOptions)
optionsExecuteOptions = oExecuteOptions

getExecuteOptions :: Dual (Endo ExecuteOptions) -> Language -> ExecuteOptions
getExecuteOptions f = appEndo (getDual f) . defaultExecuteOptions

parseOptions :: MonadIO m => [String] -> m Options
parseOptions = parseArgs optionsParser

optionsParser :: Parser Options
optionsParser =
    Options
        <$> strOption
                (mconcat
                    [ short 'i'
                    , long "input"
                    , metavar "PATH|-"
                    , help "Read Markdown from PATH"
                    , value InputStdin
                    , showDefaultWith showInput
                    ]
                )
        <*> executeOptionsParser

parseExecuteOptions :: MonadIO m => [String] -> m (Dual (Endo ExecuteOptions))
parseExecuteOptions = parseArgs executeOptionsParser

executeOptionsParser :: Parser (Dual (Endo ExecuteOptions))
executeOptionsParser = mconcat <$> sequenceA
    ([ eOptional setOutput strOption $ mconcat
         [ short 'o'
         , long "output"
         , metavar "PATH|-"
         , help "Output script to PATH, instead of execution"
         ]
     , eOptional (outputL .~) strOption $ mconcat
         [ short 's'
         , long "save"
         , metavar "PATH|-"
         , help "Save script to PATH, in addition to execution"
         ]
     , eOptional setLanguageExecuteOptions (option $ eitherReader readLanguage)
         $ mconcat
               [ short 'l'
               , long "language"
               , metavar "LANGUAGE"
               , help
               $ "Parse and execute LANGUAGE code blocks (supported: "
               <> showAllLanguages
               <> ")"
               ]
     ]
    <> map toLanguageSwitch [minBound .. maxBound]
    <> [ eOptional (shebangL .~) strOption
           $ mconcat
                 [ long "shebang"
                 , metavar "TEXT"
                 , help "Set the shebang (without '#!')"
                 ]
       , eSwitch (bannerL .~ Nothing) $ mconcat
           [long "no-banner", help "Disable any 'Generated by...' banner"]
       , eOptional (bannerL ?~) strOption
           $ mconcat [long "banner", metavar "TEXT", help "Set the banner"]
       , eSwitch (preambleL .~ Nothing)
           $ mconcat [long "no-preamble", help "Disable any preamble"]
       , eOptional (preambleL ?~) strOption
           $ mconcat
                 [long "preamble", metavar "TEXT", help "Set the preamble"]
       , eOptional (commentCharsL .~) strOption $ mconcat
           [ long "comment-chars"
           , metavar "TEXT"
           , help "Set the characters used for line comments"
           ]
       , eOptional setExec strOption
           $ mconcat
                 [long "exec", metavar "CMD", help "Execute script using CMD"]
       , eMany (executeArgsL <>~) strOption $ mconcat
           [ long "arg"
           , help "Pass additional arguments when executing"
           , metavar "ARG"
           ]
       , eFlag (inheritEnvL .~) InheritEnv Don'tInheritEnv
           $ mconcat
                 [ long "no-env"
                 , help "Don't inherit ENV in the executed process"
                 ]
       ]
    )

toLanguageSwitch :: Language -> Parser (Dual (Endo ExecuteOptions))
toLanguageSwitch language =
    eSwitch (setLanguageExecuteOptions language) $ mconcat
        [ long shown
        , help $ "Parse and execute " <> shownTag <> " code blocks" <> suffix
        ]
  where
    shownTag = unpack $ languageCodeBlockTag language
    shown = showLanguage language
    suffix
        | shown == shownTag = ""
        | otherwise = " as " <> shown

setOutput :: Output -> ExecuteOptions -> ExecuteOptions
setOutput o eo = eo & outputL .~ o & executeModeL .~ NoExecute

setExec :: String -> ExecuteOptions -> ExecuteOptions
setExec cmd eo = eo & executeModeL .~ Execute cmd & executeArgsL .~ []

eOptional
    :: (a -> b -> b)
    -> (Mod OptionFields a -> Parser a)
    -> Mod OptionFields a
    -> Parser (Dual (Endo b))
eOptional f o m = maybe mempty (Dual . Endo . f) <$> optional (o m)

eMany
    :: ([a] -> b -> b)
    -> (Mod OptionFields a -> Parser a)
    -> Mod OptionFields a
    -> Parser (Dual (Endo b))
eMany f o m = Dual . Endo . f <$> many (o m)

eSwitch :: (a -> a) -> Mod FlagFields (Dual (Endo a)) -> Parser (Dual (Endo a))
eSwitch f = flag mempty (Dual $ Endo f)

eFlag :: (a -> b -> b) -> a -> a -> Mod FlagFields a -> Parser (Dual (Endo b))
eFlag f inactive active = fmap (Dual . Endo . f) . flag inactive active

parseArgs :: MonadIO m => Parser a -> [String] -> m a
parseArgs parser = liftIO . handleParseResult . execParserPure defaultPrefs p
  where
    p =
        info (parser <**> helper)
            $ progDesc "Execute Literate Markdown programs"
            <> fullDesc
            <> footer "See litx(1) for more details."
